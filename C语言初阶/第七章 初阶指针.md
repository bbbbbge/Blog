[TOC]

## 1.指针是什么

### 介绍

> 在计算机科学中，指针是编程语言中的一个对象，利用地址，它的值直接指向存在电脑存储器中另一个地方的值。由于通过地址能找到所需的变量单元，可以说，地址指向该变量单元。因此，**将地址形象化的称为“指针”**。意思是通过它能找到以它为地址的**内存单元**。

### 理解

**内存**：是计算器的重要部件之一，也称内存储器和主存储器，它用于暂时存放CPU中的运算数据，与硬盘等外部存储器交换的数据。

> 将内存划分一个个内存单元，经过计算取一个字节大小为内存单元，并将其进行编号（地址)，通过地址就可以找到该内存单元的数据，故将地址形象称为“指针”。
>
> ![image-20210521151748630](C:\Users\lenovo\Pictures\blog\image-20210521151748630.png)

**指针**：指针是个**变量**，存放内存单元的地址（编号）

```c
#include <stdio.h>
int main()
{
 	int a = 10;		//在内存中开辟一块空间，a占4个字节
 	int* p = &a;	//这里我们对变量a，取出它的地址，可以使用&操作符。（拿到的是a第一个字节的地址）
  					//将a的地址存放在p变量中，p就是一个指针变量。
 	return 0;
}
```

**如何编址**：

**对于32位的机器**，假设有32根地址线，那么假设每根地址线在寻址时是产生一个电信号，有正电/负电（1或者0）， 那么32根地址线产生的地址就会是：

> 00000000 00000000 00000000 00000000
>
> 00000000 00000000 00000000 00000001 
>
> ...
>
> 11111111 11111111 11111111 11111111

- 这里就有2的32次方个地址。 每个地址标识一个字节，那我们就可以给（2^32^Byte== 2^32/1024^KB == 2^32/1024/1024^MB==2^32/1024/1024/1024^GB == 4GB）4G的空闲进行编址。

- 在32位的机器上，地址是32个0或者1组成二进制序列，那地址就得用4个字节的空间来存储，所以一个指针变量的大小就应该是4个字节。（1个字节==8个比特位）

  

**对于64位的机器**，编址同上。

- 在64位机器上，如果有64个地址线，那一个指针变量的大小是8个字节，才能存放一个地址.

### 小节

> 1. 指针是用来存放地址的，地址是唯一标示一块地址空间的。 
> 2. 指针的大小在32位平台是4个字节，在64位平台是8个字节。



## 2.指针和指针类型

### 介绍

> - 变量有不同的类型，整形、浮点型、字符型等等。
> - 指针也有类型
> - 指针的定义方式是： `type + *` 。针对不同变量，指针就有不同的类型，如： char* 类型的指针是为了存放 char 类型变量的地址。 short* 类型的指针是为了存放 short 类型变量的地址。 int* 类型的指针是为了存放 int 类型变量的地址。

```c
char  *pc = NULL;	//NULL：空指针，本质就是0
int   *pi = NULL;
short *ps = NULL;
long  *pl = NULL;
float *pf = NULL;
double *pd = NULL;
```

### 指针类型的意义

看一段代码：

```c
//假设为32位机器
int* pa;
char* pc;
double* pd;
printf("%d\n",sizeof(pa));//	结果：4
printf("%d\n",sizeof(pc));//	结果：4
printf("%d\n",sizeof(pd));//	结果：4
```

如果不管是什么类型的指针变量的大小都是一样的，我们为什么还要将指针区分类型呢？

看这一段代码：

```c
int a=0x11223344;// 通过调试，a存着 44 33 22 11
int* pa=&a;
*pa=0;//调试到这一步，a的值变为 00 00 00 00

//若将int* pa=&a改成char* pc=&a;
*pc=0;//调试到这一步，a的值变为 00 33 22 11
```

> 说明指针类型决定了，指针解引用的权限有多大

再看一段代码：

```c
int arr[10]={0};
int* pi=arr;
char* pc =arr;//因为指针大小一样，可以正常存储地址

printf("%p\n",pi);//调试假设结果为：004FFC40
printf("%p\n",pi+1);//结果为：004FFC44

printf("%p\n",pc);//结果为：004FFC40
printf("%p\n",pc+1);//结果为：004FFC41
```

> 说明指针类型决定了，指针走一步能走多远（步长）



### 小结

> 1. 指针类型决定了，指针解引用的权限有多大（能操作几个字节）
> 2. 指针类型决定了，指针走一步能走多远（步长）



## 3.野指针

### 介绍

> 概念：野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）

### 野指针成因

1. 指针未初始化

```c
int main()
{
    //这里的p为野指针
    int* p;//p是一个局部的指针变量，局部变量不初始化的话，默认是随机值
    *p=20;//非法访问内存
    
    return 0;
}
```

2. 指针越界放问

```c
int arr[10]=0;
int*p =arr;
int i=0;
for(i=0;i<=10;i++)//当i=10时，指针已经越界了，所指向空间不是数组的，故p就是野指针
{
    *p=i;
    p++;
}
```

3. 指针指向的空间释放

```c
int* test()
{
    int a=10;
    return &a;
}
int main()
{
    int* p=test();//调用tset函数后，test函数中创建了变量a，并且将a的地址返回出来，但是当return之后，a的生命周期也结束了，a变量被销毁。虽然指针p接收到了一个地址，但是p已经不能通过地址去访问到a
    *p=20;
    return 0;
}
```

### 如何规避野指针

> 1. 指针初始化	(若不知道指针初始化什么时，可以直接初始化NULL，但是后面指针要有自己的有效性)
>
> 2. 小心指针越界
> 3. 指针指向空间释放后，及时置NULL
> 4. 指针使用之前进行有效性检查



## 4.指针运算

### 介绍

> 指针可进行：
>
> 1. 指针加减整数
> 2. **指针减指针**：得到的时两个指针之间元素的个数（左闭右开）
> 3. 指针的关系运算

代码1：

```c
float a[5];
float* pa;
for(pa=&a[0];pa<&a[5])//pa<&a[5]：指针的关系运算
{
    *pa++=0;//++优先级高于*，所以指针先++，再解引用（指针加整数）
}
```

代码2：

```c
int arr[10]={1,2,3,4,5,6,7,8,9,10};
int* p=arr;
int* pend=arr+9;
while(p<=pend)//（指针的关系运算）
{
    printf("%d\n",*p);
    p++;//（指针加整数）
}
```

代码3：

```c
int arr[10]={1,2,3,4,5,6,7,8,9,10};
printf("%d\n",&arr[9]-&arr[0]);//结果为9	（指针-指针）

//指针-指针得到的是两个指针之间的元素个数
```

代码4：

```c
int my_strlen(char* str)
{
    int cnt=0;
    while(*str!='\0') 
    {
        cnt++;
        str++;
    }
    return cnt;
}
int main()
{
    int len=my_strlen("abc");//传到my_strlen函数中的其实是字符a的地址
    printf("%d\n",len);
    return 0;
}
```

代码5：

```c
int my_strlen(char* str)
{
    char* strat=str;
    while(*str!='\0') 
    {
        str++;
    }
    return str-start;
}
int main()
{
    int len=my_strlen("abc");
    printf("%d\n",len);
    return 0;
}
```



### 标准规定

> 允许指向数组元素的指针与指向数组最后一个元素后面的那个内存位置的指针比较，但是不允许与指向第一个元素之前的那个内存位置的指针进行比较。

代码6：(**不规范代码，不是所有编译器都能正确编译**)

```c
int a[5];
int* pa;
for(pa=&a[4];pa>=&a[0];pa--)
{
    *pa=0;
}
```



## 5.指针和数组

### 介绍

**数组名**：数组名是数组首元素的地址

```c
int arr[10]={0};
printf("%p\n",arr);-------假设结果为：0x012FFB90
printf("%p\n",&arr[0]);-------结果为：0x012FFB90
```



### 数组和地址关系

看一段代码

```c
int arr[10]={0};
int* p=arr;
int i=0;
for(i=0;i<10;i++)
{
    printf("%p <==> %p\n",&arr[i],p+i);
}

```

结果为：

![](C:\Users\lenovo\Pictures\blog\Snipaste_2021-05-22_02-04-40.png)

看这段代码的延申

```c
int arr[10]={1,2,3,4,5,6,7,8,9,10};
int* p=arr;
printf("%d\n",2[arr]);//结果为：3
printf("%d\n",arr[2]);//结果为：3
printf("%d\n",p[2]);  //结果为：3
printf("%d\n",2[p]);  //结果为：3

//[]是一个操作符，arr[2]中，2和arr是两个操作数

//arr[2] <==> *(p+2) <==> *(2+P) <==> *(2+arr) <==> *(arr+2)
//上面这些数都是等价的

//由于*(arr+2) <==> arr[2]
//那么*(2+arr) <==> 2[arr]，*(p+2) <==> p[2]，*(2+P) <==> 2[p]

//得到2[arr] <==> arr[2] <==> p[2] <==> 2[p]
```



## 6.二级指针

### 介绍

> 指针变量也是变量，是变量就有地址，那指针变量的地址存放在哪里？ 二级指针中

```c
int a=10;

int* pa=&a;//pa是指针变量，一级指针
		   //由于pa是指针,故定义时前面加上*，而指向的变量为int型变量，故类型为int*

int** ppa=&pa;//pa也是变量，&pa取出pa在内存中起始地址，二级指针
			  //由于ppa是指针，故定义时前面加上*，而指向的变量为int*型变量，故类型为int**
```

![image-20210522030020596](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210522030020596.png)

### 二级指针运算

> 1. *ppa 通过对ppa中的地址进行解引用，这样找到的是 pa ， *ppa 其实访问的就是 pa
> 2. **ppa 先通过 *ppa 找到 pa ,然后对 pa 进行解引用操作： *pa ，那找到的是 a

```c
int b = 20;
*ppa = &b;//等价于 pa = &b;

**ppa = 30;
//等价于*pa = 30;
//等价于a = 30;
```



## 7.指针数组

### 介绍

> - 指针数组，本质还是数组
> - 数组其实已经有整型数组，字符数组，而指针数组也是一样的，是**存放指针的数组**

```c
int arr[10];//整型数组——存放整型的数组
char ch[5];//字符数组——存放字符的数组

//指针数组——存放指针的数组
int* parr[5];//整型指针数组，有五个元素，每个元素是一个整形指针
```



## 总结

> 以上都是个人对于指针的一些总结，至于还有的一些指针知识，后面将会再做一个章节。如果里面有错误的希望大家帮我指正，也希望这章的内容大家能喜欢。\\( ^ -- ^ )/

