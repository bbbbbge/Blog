[TOC]

## 1. 什么是bug？

俺就是bug

![](C:\Users\lenovo\Pictures\blog\440px-First_Computer_Bug,_1945.jpg)

懂了没？这还没懂？上面的就是俺啊。本虫就是第一次被发现的导致计算机错误的bug，小名（飞鹅）。

![](C:\Users\lenovo\Pictures\blog\微信图片_20210523154511.jpg)

### 正经介绍

> **Bug**：即程序错误，是程序设计中的术语，是指在软件运行中因为程序本身有错误而造成的功能不正常、死机、数据丢失、非正常中断等现象。有些程序错误会造成计算机安全隐患，此时叫做**漏洞**。

既然知道了bug是啥，那你们就懂了，我们就是“害虫的妈妈”，到处生产bug。

![](C:\Users\lenovo\Pictures\blog\微信图片_20210523161646.jpg)

那如何做好安全措施呢？你不仅得**写出一手好代码，还得学会debug（调试）**。



## 2. 调试是什么？

### 介绍

> **调试**：（英语：Debugging / Debug），又称除错，是发现和减少计算机程序或电子仪器设备中程序错误的一个过程。

既然知道了什么是调试，那么怎么调试呢？很多有热血、有激情的程序员一写代码就是这样的：

![](C:\Users\lenovo\Pictures\blog\微信图片_20210523161642.jpg)

嗯对，然后开始调试就是这样的！

![](C:\Users\lenovo\Pictures\blog\meme-gif-tumblr-5.gif)

### 调试的基本步骤

> 1. 发现程序错误的存在
> 2. 以隔离、消除等方式对错误进行定位
> 3. 确定错误产生的原因
> 4. 提出纠正错误的解决办法
> 5. 对程序错误予以改正，重新测试

其实平常大家找bug应该都有自己的习惯。如果你没有，可以试试养成自己的习惯，步骤用处不大，但好的调试习惯绝对，绝对，绝对很高级！



## 3. windows环境调试介绍

为啥是windows环境调试？因为俺现在只会windows的调试。

![](C:\Users\lenovo\Pictures\blog\微信图片_20210523160350.jpg)

### 1）调试环境的准备

> 在环境中选择 debug 选项，才能使代码正常调试。不知道debug的xdm，后面会告诉你哒。



### 2）调试常用快捷键

当我们点击编译器调试的时候，就会出现一大堆balabala的按键，但是学会几个快捷键，效率直接起飞啊！

**F5**

> 启动调试，经常用来直接跳到下一个断点处。

F9

> 创建和取消断点，可以在程序的任意位置设置断点。这样就可以使得程序在想要的位置随意停止执行，继而一步步执行下去。

F10

> 逐过程，通常用来处理一个过程，一个过程可以是一次函数调用，或者是一条语句。

F11

> 逐语句，就是每次都执行一条语句，但是这个快捷键可以使我们的执行逻辑进入函数内部（这是 最长用的）。

Ctrl + F5

> 开始执行不调试，如果你想让程序直接运行起来而不调试就可以直接使用。



### 3）调试时查看程序当前信息

> 当你开始调试后，点击 **调试** — **窗口** 后就会出现，而你想要在调试时查看的数据可以在这里选择的打开
>
> ![image-20210524223005685](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210524223005685.png)



## 4. Debug和Release

### 介绍

> - **Debug 通常称为调试版本**，它包含调试信息，并且不作任何优化，便于程序员调试程序。
> - **Release 称为发布版本**，它往往是进行了各种优化，使得程序在代码大小和运行速度上都是最优的，以便用户很好地使用。



### 注意

> 有时 debug 模式去编译，程序的结果是死循环。 但是 release 模式去编译，程序没有死循环。 这是因为优化导致的。因为变量在内存中开辟的顺序发生了变化，影响到了程序执行的结果。



## 5. 调试时遇见的一个例子

```c
#include <stdio.h>
int main()
{
	int i = 0;
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	for (i = 0; i <= 12; i++)
	{
		arr[i] = 0;
		printf("hehe\n");
	}
	return 0;
}
```

通过编译，结果为无限打印”hehe“，死循环，为什么呢？

通过调试我们发现第一次循环到i=12时，i的地址和arr[12]相同，arr[12]=0，即将i变成0。通过思考总结为：

> 1. 因为i和arr时局部变量，局部变量是放在**栈区**上的（不是数据结构的栈）
>
> 2. 栈区内存的使用习惯是：先使用高地址空间，再使用低地址空间
>
> 3. 数组随着下标的增长，地址是由低到高变化的
>
>    ![](C:\Users\lenovo\Pictures\blog\微信图片_20210524015643.png)
>
> 4. 为什么arr[9]和i差两个地址呢呢，可能是我所用编译器的特性（vs2017），不同编译器可能不同



## 6. 如何写出好的代码

### 介绍

**优秀的代码：**

> 1. 代码运行正常
> 2. bug很少
> 3. 效率高
> 4. 可读性高
> 5. 可维护性高
> 6. 注释清晰
> 7. 文档齐全

**常见的coding技巧：**

> 1. 使用assert
> 2. 尽量使用const
> 3. 养成良好的编码风格
> 4. 添加必要的注释
> 5. 避免编码的陷阱。

### 示范

**模拟打印strcpy函数**

> **注意**：strcpy函数还会将原字符串最后的'\0'拷贝到目标函数中

代码1

```c
#include <stdio.h>
void my_strcpy(char* dest, char* src)
{
	while(*src != '\0')
	{ 
		*dest = *src;
		dest++;
		src++;
	}
	*dest = *src;
}
int main()
{
	char a[20] = "flkhjsfasd";
	char b[] = "hello";
	my_strcpy(a, b);//目标字符串起始地址，原字符串起始地址
	printf("%s", a);
	return 0;
}

```

代码2（只更改my_strcpy函数）

```c
void my_strcpy(char* dest, char* src)
{
	while (*dest++ = *src++)//既copy了'\0'，又使得循环停止
	{
		;
	}
}
```

代码3

> - 如果传给src的不小心写成空指针，由于空指针指向地址是随机的，那么src没有一个合法的空间，故解引用的时候就出现了问题，程序则崩溃了。
> - 故我们可以通过assert（断言）来起预防作用，去验证一些假设的情况
> - 使用assert前需要上头文件<assert.h>

```c
void my_strcpy(char* dest, char* src)
{
    assert(src!=NULL);//如果条件为真，就没事，如果为假，编译时，断言就会报错，并有报错信息
    assert(dest!=NULL);
	while (*dest++ = *src++)
	{
		;
	}
}
```

结果为：

![](C:\Users\lenovo\Pictures\blog\Snipaste_2021-05-24_15-49-57.png)

代码4

> 再通过比较与strcpy函数定义的形参，发现他里面src指针前面有const，那么const又会让这个程序变得怎样呢？
>
> ![](C:\Users\lenovo\Pictures\blog\Snipaste_2021-05-24_15-56-10.png)
>
> **const修饰指针变量的时候：**
>
> 1. const如果放在*的左边，修饰的是指针指向的内容，保证指针指向的内容不能通过指针来改变。但是指针变量本身的内容可变。
> 2. const如果放在*的右边，修饰的是指针变量本身，保证了指针变量的内容不能修改，但是指针指向的内容，可以通过指针改变。

如果写程序时，将dest和src写反了，那么也会编译，防止这个错误，可以在形参char* src前加const，因为src指向的内容是不要改变的，所以通过编译报错，找到错误。

```c
void my_strcpy(char* dest, const char* src)
{
    assert(src!=NULL);
    assert(dest!=NULL);
	while (*src++ = *dest++)//报错，就可以进行修改
	{
		;
	}
}
```

结果为：

![](C:\Users\lenovo\Pictures\blog\Snipaste_2021-05-24_16-13-39.png)

代码5

> 最后再将返回类型也改成char*，那么这个函数就可以直接被打印了

```c
char* my_strcpy(char* dest, const char* src)
{
    assert(src!=NULL);
    assert(dest!=NULL);
    char* ret=dest;
	while (*src++ = *dest++)//报错，就可以进行修改
	{
		;
	}
    return ret;
}
```

### 小节

> 上面的代码示范，模拟了strcpy函数，在模拟的同时不仅仅会让你的代码样式更加优秀，还会助于你去理解代码。



## 7. 编程常见的错误

**编译型错误**

> 直接看错误提示信息（双击），解决问题，或者凭借经验就可以搞定。相对来说简单。

**链接型错误**

> 看错误提示信息，主要在代码中找到错误信息中的标识符，然后定位问题所在。一般是标识符名不存在或者拼写错误。

**运行时错误**

> 借助调试，逐步定位问题。最难搞。



## 总结

> 今天是关于调试的一个总结，至于很多地方，如写调试时查看程序当前信息我并没有一个个细致讲有啥用，就是希望大家可以自己主动尝试，去瞎折腾，这样你才能对你所用的编译器，对调试这个环境有更深的理解。希望大家喜欢啦，如果有错误请大家多多指正！