[TOC]

## 1. 数据类型

### 回顾内置类型

```c
char			//字符数据类型
short			//短整型
int    			//整型
long    		//长整型
long long    	//更长的整型
float			//单精度浮点型
double    		//双精度浮点型
```

### 意义

> 1. 了解使用这个类型开辟内存空间的大小（大小决定了使用范围）
> 2. 拥有看待内存空间的视角（如float存的就是浮点数，int存的就是整数）

### 基本分类

**整型家族：**

![](C:\Users\lenovo\Pictures\blog\Snipaste_2021-05-26_12-13-17.png)

> char之所以是整型家族的一员，是因为它底层存的其实是ASCII值，ASCII是整数所以将char分到整型家族

**浮点型家族：**

```c
double	//双精度
float	//单精度
```

**构造类型：**

```c
//数组类型
struct	//结构体类型	
enum	//枚举类型	 
union	//联合类型	 
```

> 数组为什么放在自定义类型呢？我们知道数组类型其实是元素类型+数组大小，如：
>
> int arr[10];——类型名为：int [10]
>
> char str[5];——类型名为：char [5]
>
> 故数据的类型不同，数组大小不一样，数组名就不同，可看作为自定义类型

**指针类型：**

```c
int* pi;	//整型
char* pc;	//字符指针
float* pf;	//单精度浮点型指针
void* pv;	//空指针
//...
```

**空类型：**

```c
void test();	//函数返回类型
void test(void);//函数参数		 
void* p;		//指针
```

> - void 表示空类型（无类型）
> - 通常应用于函数的返回类型、函数的参数、指针类型



## 2. 整型在内存中的存储

### 介绍

> - 数据在内存中是以2进制的形式存储的
> - 对于整数来说，整数二进制的表示形式有三种：原码、反码、补码
> - 整型范围定义在limits.h中（可以用在路径中搜索打开具体了解）



### 原码、反码、补码

> **原码**：直接将数据的数值翻译成二进制序列就是原码

> **反码**：原码的符号位不变，其他位按位取反，得到的就是反码

> **补码**：反码+1，得到的就是补码

**注意**

> 1. 正整数的原码、反码、补码相同
>
> 2. 负整数的原码、反码、补码按照三者之间的关系进行换算
> 3. 整数在内存中存储的是补码

如：

```c
int a=10;
//原码：00000000000000000000000000010010
//因为a是正整数，故反码、补码和原码相同
//调试时查看内存，地址&a存的是：0a 00 00 00
//0a 00 00 00，其实是10的16进制形式并且倒了过来
//10的十六进制形式是：00 00 00 0a
//翻译成二机制即为：00000000000000000000000000010010
```

再看一个例子：

```c
int b=-5;
//原码：10000000000000000000000000000101
//反码：11111111111111111111111111111010
//补码：11111111111111111111111111111011
//调试时查看内存，地址&b存的是：fb ff ff ff
//fb ff ff ff，其实是-5的十六进制形式并且倒了过来
//将ff ff ff fb翻译成二进制为：11111111111111111111111111111011
```

通过上面的介绍，我们可以知道，一个整型是以什么形式存储在内存中了，但是为什么是内存中存的是补码呢？



### 用补码存储的原因

> 在计算机系统中，整数数值一律用补码来表示和存储。原因在于，
>
> 1. 使用补码，可以将符号位和数值域统一处理
> 2. 加法和减法也可以统一处理（**CPU只有加法器**）
> 3. 补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路。

解释点1、2：

```c
//计算：1-1
//由于CPU只有加法器，没有减法器，故1-1，在CPU中是作1+（-1）处理

//如果以原码存储，那么：
//1：00000000000000000000000000000001
//-1：10000000000000000000000000000001
//1+（-1）：10000000000000000000000000000010，转化为十进制为-2，不符合结果

//如果以补码存储，那么：
//1：00000000000000000000000000000001
//-1：11111111111111111111111111111111
//1+（-1）：00000000000000000000000000000000，转化为十进制为0，符合结果
//1+（-1）时最前面多的那个进位的1去掉，因为超过32位了
```

解释点3：

> - 对于负整数，原码取反+1，得到补码
> - 对于负整数，补码取反+1，也可以得到于原码



到这里，我们就比较清楚整型的存储了，但是有个细节大家发现没，为什么在内存中整型补码的十六进制存储顺序是倒着的，就像10，存的是0a 00 00 00，就像-5，存的是fb ff ff ff呢？下面的内容将为你解谜。



## 3. 大小端字节序

### 介绍

首先我们看一个思考题：![](C:\Users\lenovo\Pictures\blog\Snipaste_2021-05-26_16-36-21.png)

> 我们要知道当我们将每个字节怎么存进去，怎么拿出来就行，这样就可以还原存入的数据，而第一个和第二个例子存储进内存的顺序是有规律的，而第三第四个例子存储的顺序虽然可行，但是过于复杂，故最终只保留了上面两种存储顺序。

而这里我们是按字节的顺序存入的，如上述例子里，11是一个字节，22是一个字节。故我们最终分成了两种字节序：大端字节序和小端字节序

**大端字节序**

> 数据的低位，保存在内存的高地址中；而数据的高位，保存在内存的低地址中

**小端字节序**

> 数据的低位，保存在内存的低地址中；而数据的高位,，保存在内存的高地址中

所以我们可以知道，一开始存的补码的顺序是倒着的，这是因为我的编译器是按照小端字节序存入的。下面我们再借助一些资料更加深入了解为何要分大小端字节序。



### 分类原因

> - 因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为8bit。但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型（要看具 体的编译器）。另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如果将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。
>
> -  例如一个 16bit 的 short 型 x ，在内存中的地址为 0x0010 ， x 的值为 0x1122 ，那么 0x11 为高字节， 0x22 为低字节。对于大端模式，就将 0x11 放在低地址中，即 0x0010 中， 0x22 放在高地址中，即 0x0011 中。小端模式，刚好相反。我们常用的 X86 结构是小端模式，而 KEILC51 则为大端模式。很多的 ARM，DSP 都为小端模式。有些 ARM 处理器还可以由硬件来选择是大端模式还是小端模式。



## 4. 习题

**1. 写一个代码判断当前机器的字节序**

```c
//我们只要找到一个简单的数进行判断即可，选取1，并且只要比较低位第一个字节的数据。
#include <stdio.h>
int main()
{
    int a=1;
    char* p=(char*)&a;
    if(*p==1)
        printf("小端");
    else
        printf("大端");
}
```



**2. 思考输出什么？**

```c
#include <stdio.h>
int main()
{
	char a = -1;
	signed char b = -1;
	unsigned char c = -1;
	printf("a=%d,b=%d,c=%d", a, b, c);
	return 0;
}
//结果为：a=-1,b=-1,c=255
```

![](C:\Users\lenovo\Pictures\blog\Snipaste_2021-05-26_18-34-15.png)



**3. 思考输出什么？**

```c
#include <stdio.h>
int main()
{
	char a = -128;
	printf("%u\n", a);
	return 0;
}
//结果为：4294967168
```

![](C:\Users\lenovo\Pictures\blog\Snipaste_2021-05-26_20-56-55.png)



**4. char数据的范围为什么是127~-128呢？**

![](C:\Users\lenovo\Pictures\blog\Snipaste_2021-05-26_22-23-00.png)



**5. 思考输出什么？**

```c
#include <stdio.h>
int main()
{
	unsigned int i;
	for (i = 9; i >= 0; i--)
	{
		printf("%u\n", i);
	}
	return 0;
}
//结果为：死循环
//因为无符号数肯定大于等于0，i变成-1时，实则是变成了补码为32个1的正整数
```



**6. 思考输出什么？**

```c
#include <stdio.h>
int main()
{
	char a[1000];
	int i;
	for (i = 0; i < 1000; i++)
	{
		a[i] = -1 - i;
	}
	printf("%d", strlen(a));
	return 0;
}
//结果为：255
//因为char为一个字节当i=-1到i=-128时都可以将数据正常存入char内
//当i=-129时，原码为 10000000000000000000000010000001，补码为11111111111111111111111101111111
//截断为：01111111，易知十进制位为127，然后随i递增，a[i]的值逐渐递减，直到为0，之前共255个数
```



**7. 思考输出什么？**

```c
#include <stdio.h>
unsigned char i = 0;
int main()
{
	for (i = 0; i <= 255; i++)
	{
		printf("hello world\n");
	}
	return 0;
}
//结果为：死循环
//当i=256时，原码被截断为11111111，十进制依旧是255，故i的值永远为255
```



希望大家看到这里时，已经把上面的那些题目都给理清楚了，这样的话，相信你对整数在内存中的存储有了一个很好的掌握。



### 补充

> 1. char 到底是 signed char 还是 unsigned char，C语言标准并没有规定，取决于编译器
> 2. 但是 int、short 都表示为 signed int、signed short



## 5. 浮点型在内存中的存储

### 介绍

> - 浮点数家族有：float、double、long double 类型
> - 如：3.14159、1e6
> - 浮点型的范围定义在在float.h中（可以用在路径中搜索打开具体了解）

首先我们思考一个题目：

```c
#include <stdio.h>
int main()
{
	int n = 9;
	float* pf = (float*)&n;
	printf("n的值为:%d\n",n);
	printf("*p的值为:%f\n", *pf);

	*pf = 9.0;
	printf("n的值为:%d\n", n);
	printf("*p的值为:%f\n", *pf);
	return 0;f
}
/*结果为：
n的值为:9
*p的值为:0.000000
n的值为:1091567616
*p的值为:9.000000
*/
```

> 1. 如果按照小端字节序存入内存，那么整型n在内存中的十六进制展示是 09 00 00 00，而float*访问的是4个字节
> 2. 进行强制类型转换并不会改变n的存储，故第一个结果其实就是9
> 3. 而 *pf访问的是四个字节，如果按照整型读取，第二个结果打印的应该是9.000000，但是结果并不是，**说明浮点型有自己的读取方法**
> 4. 当*pf = 9.0后，即通过指针改变了n的值，但是按照整型输出方式，第三个结果打印的应该是9，但是结果不是，**说明浮点型有自己的存入内存的方法**
> 5. 而最后一个结果就是按照浮点型自己的存入和读取的方法，故结果为9.000000

这个题目告诉我们浮点型在内存中有自己的存储和读取方法，而接下来我们将对其进行解析，至于上面这道题结果的所以然，我们等到最后再来探解。



### 相关资料

根据**国际标准IEEE（电气和电子工程协会）754**，任意一个**二进制浮点数V**可以表示成下面的形式：

> - (-1)^S^ * M * 2^E^
> - (-1)^s^表示符号位，当s=0，V为正数；当s=1，V为负数
> - M表示有效数字，大于等于1，小于2
> - 2^E^表示指数位

怎样转化成上述形式呢，我们可以举个例子：

> - 首先我们要知道，如5.5是一个二进制，我们将小数点前后分成两部分，小数点前的5，写成二进制是101，小数点之后的5其实就是2^-1^，即转化为二进制就是1，故5.5的二进制是101.1
> - 然后将101.1用科学计数法的形式表示：1.011*2^2^（原理跟十进制一样）
> - 最后写成：(-1)^0^*1.011*2^2^
> - 而s=0，M=1.011，E=2

通过上述例子我们可以知道：

> 1. 十进制的5.0，写成二进制是 101.0 ，相当于 1.01*2^2^。按照上面V的格式，s=0， M=1.01，E=2
> 2. 十进制的-5.0，写成二进制是 -101.0 ，相当于 -1.01*2^2^。按照上面V的格式，s=1，M=1.01，E=2

既然了解了浮点型十进制是怎样转化成二进制的，以及其表示形式，我么们知道根据s，M，E，我们可以有规律的将浮点型的二进制与十进制互相转化。

那么怎么将数据存储进去呢？我们可以先看看浮点型在内存中的存储模型。



### 存储模型

**IEEE 754规定：**对于32位的浮点数（float），最高的1位是符号位s，接着的8位是指数E，剩下的23位为有效数字M![](C:\Users\lenovo\Pictures\blog\Snipaste_2021-05-27_22-56-09.png)

**IEEE 754规定：**对于64位的浮点数（double），最高的1位是符号位s，接着的11位是指数E，剩下的52位为有效数字M![](C:\Users\lenovo\Pictures\blog\Snipaste_2021-05-27_22-58-33.png)



### 相关规定

**IEEE 754规定：**在计算机内部保存M时（1≤M<2），默认这个数的第一位总是1，因此可以被舍去，只保存后面的小数部分。

> **比如：**M为1.01的时候，只保存01，等到读取的时候，再把第一位的1加上去。

> **目的：**这样做可以节省1位有效数字，增大精度。 以32位浮点数为例，留给M只有23位，将第一位的1舍去以后，等于可以保存24位有效数字。



**IEEE 754规定：**存入内存时E的真实值必须再加上一个中间数，对于8位的E，这个中间数是127；对于11位的E，这个中间数是1023。

> **原因：**E为一个无符号整数（unsigned int）这意味着，如果E为8位，它的取值范围为0~255；如果E为11位， 它的取值范围为0~2047。但是科学计数法中的E是可以出现**负数的**

> 比如：保存数据为0.1时，写成V的形式为：1^0^*1*2^-1^，E=-1，但是E为无符号数，故对于float型，E要加上127，即变成126后再存入E的八个比特位中



### 存储方式

> 1. 按照IEEE 754规定，将十进制的数据转换成V的形式，得到s，M，E。
> 2. s直接存进去s的位置。将E加上中间数之后，转换成二进制的形式存入E的位置。至于M，将其小数点后面数字存入M位置的最左端，右边剩余的位置补0

![](C:\Users\lenovo\Pictures\blog\Snipaste_2021-05-27_23-53-45.png)

而我通过自己的编译器调试后发现内存中存的二进制展现成16进制就是：`00 00 b0 40`，符合小端字节序



### 读取内存方式

> 我们需要将存入内存的s、E、M还原。其中s可以直接观察，至于E和M的还原，将按照E的值分成三种情况

**E不全为0或不全为1**

> 将指数E的计算值减去127（或1023），得到真实值，再将有效数字M前加上第一位的1

**E全为0**

> 将指数E等于1-127（或1-1023），得到真实值。有效数字M不再加上第一位的1，而是还原为 0.xxxxxx 的小数。这样做是为了表示±0，以及接近于0的很小的数字

**E全为1**

> 如果有效数字M全为0，表示±无穷大（正负取决于符号位s）



到了这里，对于浮点型在内存中的存储我的总结就结束了。最后让我们回到之前那个没有解决的题目。

```c
#include <stdio.h>
int main()
{
	int n = 9;
	float* pf = (float*)&n;
	printf("n的值为:%d\n",n);
	printf("*p的值为:%f\n", *pf);

	*pf = 9.0;
	printf("n的值为:%d\n", n);
	printf("*p的值为:%f\n", *pf);
	return 0;f
}
/*结果为：
n的值为:9
*p的值为:0.000000
n的值为:1091567616
*p的值为:9.000000
*/
```

![](C:\Users\lenovo\Pictures\blog\Snipaste_2021-05-28_01-59-00.png)



## 6. 总结

> 这章将C语言数据在内存中的存储梳理了一遍。如果其中有哪些地方有错误的话，希望大家可以帮我指正，然后这篇文章个人在总结的时候收获很大，也希望能给你们带来很大的帮助！